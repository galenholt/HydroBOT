<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Read in data and aggregate along theme and spatial dimension — read_and_agg • HydroBOT</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Read in data and aggregate along theme and spatial dimension — read_and_agg"><meta name="description" content="Allows passing only paths to data rather than objects (though objects work as
well for consistency). Wrapper over read_and_geo(), make_edges() and
multi_aggregate(). Particularly useful if we want to pass parameters as
strings from a config before anything is read in, and parallelisation (set a
future::plan())."><meta property="og:description" content="Allows passing only paths to data rather than objects (though objects work as
well for consistency). Wrapper over read_and_geo(), make_edges() and
multi_aggregate(). Particularly useful if we want to pass parameters as
strings from a config before anything is read in, and parallelisation (set a
future::plan())."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">HydroBOT</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.4.9006</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Read in data and aggregate along theme and spatial dimension</h1>

      <div class="d-none name"><code>read_and_agg.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Allows passing only paths to data rather than objects (though objects work as
well for consistency). Wrapper over <code><a href="read_and_geo.html">read_and_geo()</a></code>, <code><a href="make_edges.html">make_edges()</a></code> and
<code><a href="multi_aggregate.html">multi_aggregate()</a></code>. Particularly useful if we want to pass parameters as
strings from a config before anything is read in, and parallelisation (set a
<code><a href="https://future.futureverse.org/reference/plan.html" class="external-link">future::plan()</a></code>).</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">read_and_agg</span><span class="op">(</span></span>
<span>  <span class="va">datpath</span>,</span>
<span>  <span class="va">type</span>,</span>
<span>  <span class="va">geopath</span>,</span>
<span>  <span class="va">causalpath</span>,</span>
<span>  groupers <span class="op">=</span> <span class="st">"scenario"</span>,</span>
<span>  group_until <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">groupers</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  prepfun <span class="op">=</span> <span class="st">"prep_ewr_output"</span>,</span>
<span>  prepargs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  <span class="va">aggCols</span>,</span>
<span>  <span class="va">aggsequence</span>,</span>
<span>  <span class="va">funsequence</span>,</span>
<span>  saveintermediate <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  namehistory <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  keepAllPolys <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  failmissing <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  auto_ewr_PU <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  pseudo_spatial <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  returnList <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  savepath <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  extrameta <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  rparallel <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  par_recursive <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  savepar <span class="op">=</span> <span class="st">"combine"</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-datpath">datpath<a class="anchor" aria-label="anchor" href="#arg-datpath"></a></dt>
<dd><p>path to indicator data, or indicator data itself as a data
frame. Currently needs to be EWR (same as <code>ewrpath</code> argument in
<code><a href="read_and_geo.html">read_and_geo()</a></code>), but left more general here for future</p></dd>


<dt id="arg-type">type<a class="anchor" aria-label="anchor" href="#arg-type"></a></dt>
<dd><p>character, a grep for the files to choose. The special case 'everything' gets all files</p></dd>


<dt id="arg-geopath">geopath<a class="anchor" aria-label="anchor" href="#arg-geopath"></a></dt>
<dd><p>sf object with geographic locations matching a column in the data, or path to a csv with gauge locations in lat/long (assumes BOM
currently) or a shapefile</p></dd>


<dt id="arg-causalpath">causalpath<a class="anchor" aria-label="anchor" href="#arg-causalpath"></a></dt>
<dd><p>path to the causal relationships .rds file or the causal
network list object or its name</p></dd>


<dt id="arg-groupers">groupers<a class="anchor" aria-label="anchor" href="#arg-groupers"></a></dt>
<dd><p>as in <code><a href="general_aggregate.html">general_aggregate()</a></code>, with the note that these should
be all grouping columns <em>except</em> theme and spatial groupings. These are
both automatically added to <code>groupers</code> according to <code>aggsequence</code> before
passing to <code><a href="general_aggregate.html">general_aggregate()</a></code>.</p></dd>


<dt id="arg-group-until">group_until<a class="anchor" aria-label="anchor" href="#arg-group-until"></a></dt>
<dd><p>named list of groupers (column names) and the step to
which they should be retained. Default NA (retain all groupers for all
steps). <em>FOR EWR USE, best option is</em> <code>group_until = list(SWSDLName = 'sdl_units', planning_unit_name = 'sdl_units', gauge = is_notpoint)</code>. This
groups by planning unit and gauge and planning unit until larger spatial
grouping has happened, dealing with the issue of gauges reporting into
multiple PUs and SDLs. Leaving 'gauge' off is mathematically safe, since
the gauge geometry forces that grouping, but then the 'gauge' column gets
dropped. Step can be an index, name, or a function that evaluates to TRUE
or FALSE when run on the aggregation sequence. Named list does not need to
contain all groupers, but if so, those that persist throughout should be
given NA or numeric values longer than aggsequence. Vectors the length of
groupers usually work, but are less-well supported.</p></dd>


<dt id="arg-prepfun">prepfun<a class="anchor" aria-label="anchor" href="#arg-prepfun"></a></dt>
<dd><p>a function that does any post-read and pre-aggregation
preparation of the module data. This is where mutates should go. If no data
transformation is needed, use <code><a href="https://rdrr.io/r/base/identity.html" class="external-link">identity()</a></code>. That should be the default for
generality, but given the common use with the EWR tool, the defaults for
EWR tool are included in HydroBOT (and <code><a href="prep_ewr_output.html">prep_ewr_output()</a></code> is the default
here).</p></dd>


<dt id="arg-prepargs">prepargs<a class="anchor" aria-label="anchor" href="#arg-prepargs"></a></dt>
<dd><p>a list of arguments to <code>prepfun</code>. e.g. <code>list(type = 'achievement', add_max = FALSE)</code>. Setting <code>prepargs = list(type = achievement')</code> and <code>type = 'yearly'</code> is a better (more
general) way to declare that processing.</p></dd>


<dt id="arg-aggcols">aggCols<a class="anchor" aria-label="anchor" href="#arg-aggcols"></a></dt>
<dd><p>an expression for the columns to aggregate (the data columns).
See <code>selectcreator</code> for formats</p></dd>


<dt id="arg-aggsequence">aggsequence<a class="anchor" aria-label="anchor" href="#arg-aggsequence"></a></dt>
<dd><p>a named list of aggregation steps in the order to apply
them. Entries for theme aggregation should be character vectors- e.g. <code>name = c('from_theme', 'to_theme')</code>. Entries for spatial aggregation should be
the sf polygon to aggregate to, e.g. <code>name = sfpolygons</code> or a length-1
character, e.g. <code>name = "sfpolygons"</code>. The latter requires the object to be
available with <code>get("sfpolygons")</code>, but allows passing characters rather
than objects. Not requiring names and is high on the list of improvements.
If we want to be able to re-run from auto-saved metadata params, we need
the names of the spatial levels to match the object, e.g. basin: basin.</p></dd>


<dt id="arg-funsequence">funsequence<a class="anchor" aria-label="anchor" href="#arg-funsequence"></a></dt>
<dd><p>a list of aggregation functions to apply in the order to
apply them. Each list entry can be one value, e.g. a character or bare
name, or can be multiple if multiple aggregations should be done at that
step, e.g. <code>c('ArithmeticMean', 'LimitingFactor')</code>. The entries can also be
lists themselves, useful for passing functions with arguments, e.g <code>list(wm = ~weighted.mean(., w = area, na.rm = TRUE))</code>. <em>Important:</em> as of <code>dplyr</code>
1.1, if these are anonymous functions that refer to data variables (like
the <code>w = area</code> argument in the <code><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean()</a></code> example), that list needs
to be wrapped in <code><a href="https://rlang.r-lib.org/reference/defusing-advanced.html" class="external-link">rlang::quo()</a></code>, e.g. <code>rlang::quo(list(wm = ~weighted.mean(., w = area, na.rm = TRUE))</code>. And we can no longer mix
character and other forms in the same sub-list (single aggregation step).</p></dd>


<dt id="arg-saveintermediate">saveintermediate<a class="anchor" aria-label="anchor" href="#arg-saveintermediate"></a></dt>
<dd><p>logical, default <code>FALSE</code>. * <code>FALSE</code> (the default):
Save only the final result as a tibble or sf * <code>TRUE</code>: Save every step of
the aggregation as a tibble or sf in a list</p></dd>


<dt id="arg-namehistory">namehistory<a class="anchor" aria-label="anchor" href="#arg-namehistory"></a></dt>
<dd><p>logical, default <code>TRUE</code>.</p><ul><li><p><code>TRUE</code> (the default): The name of the aggregated column(s) retain the full aggregation history of the form
<code>agglevelN_aggfunctionN_...agglevel1_aggfunction1_originalcolumn</code>. This is
ugly, but saves memory and says exactly what the values in each column are.</p></li>
<li><p><code>FALSE</code>: The aggregation history is moved out of the column names and
into new columns that define it using <code><a href="agg_names_to_cols.html">agg_names_to_cols()</a></code>. The column
name(s) become(s) the original column name(s) specified by <code>aggCols</code>. This
is far cleaner and easier for analysis (e.g. filtering on aggregation
functions at a particular step), but increases the size of the dataset and
the meaning of the values in the aggregation column have to be interpreted
with the values in the new columns defining history.</p></li>
</ul></dd>


<dt id="arg-keepallpolys">keepAllPolys<a class="anchor" aria-label="anchor" href="#arg-keepallpolys"></a></dt>
<dd><p>logical, default <code>FALSE</code>. Should polygons in <code>to_geo</code>
that have no values in <code>dat</code> be retained? The default <code>FALSE</code> keeps NA
polygons from cluttering things up, but <code>TRUE</code> can be useful to not lose
them, especially for later plotting. However, it is typically best from a
data and cleanliness perspective to use <code>FALSE</code> here and use the bare set
of polys as an <code>underlay</code> in <code><a href="plot_outcomes.html">plot_outcomes()</a></code>.</p></dd>


<dt id="arg-failmissing">failmissing<a class="anchor" aria-label="anchor" href="#arg-failmissing"></a></dt>
<dd><p>logical, default <code>TRUE</code>: fail if the requested grouping or
aggregation columns not exist. If <code>FALSE</code>, proceed with those that do exist
and silently drop those that don't. Similar to <code><a href="https://tidyselect.r-lib.org/reference/all_of.html" class="external-link">tidyselect::all_of()</a></code> vs
<code><a href="https://tidyselect.r-lib.org/reference/all_of.html" class="external-link">tidyselect::any_of()</a></code> in <code>tidyselect</code></p></dd>


<dt id="arg-auto-ewr-pu">auto_ewr_PU<a class="anchor" aria-label="anchor" href="#arg-auto-ewr-pu"></a></dt>
<dd><p>logical, default <code>FALSE</code>. Auto-detect EWRs and enforce
appropriate theme and spatial scaling related to gauges and planning units,
as defined in <code><a href="theme_aggregate.html">theme_aggregate()</a></code> and <code><a href="spatial_aggregate.html">spatial_aggregate()</a></code>. Specifically,
if <code>TRUE</code>, this automatically manages the <code>group_until</code> and
<code>pseudo_spatial</code> arguments.</p></dd>


<dt id="arg-pseudo-spatial">pseudo_spatial<a class="anchor" aria-label="anchor" href="#arg-pseudo-spatial"></a></dt>
<dd><p>a character or numeric vector giving the <em>names or
indices</em> (NOT the column names to join on) of aggsequence that should have
'psuedo-spatial' aggregation. This is when we go from one spatial data
level to another, but do the join and aggregation with a non-spatial
<code><a href="https://dplyr.tidyverse.org/reference/mutate-joins.html" class="external-link">dplyr::left_join()</a></code>. It is developed for the EWR situation, where the
incoming data is indexed to gauges, planning units, and sdl units, but has
gauge point geometry, and spatial joining to planning units or sdl is not
appropriate, because single gauges affect multiple units. So it would join
to the <code>planning_units</code> or <code>sdl_units</code> by column names instead of
spatially, and then aggregate according to those units. <em>For EWR use,
typically the best option is <code>pseudo_spatial = c('planning_units', 'sdl_units')</code>, with the grouping to sdls only pseudo because some planning
units spill over sdl boundaries.</em></p></dd>


<dt id="arg-returnlist">returnList<a class="anchor" aria-label="anchor" href="#arg-returnlist"></a></dt>
<dd><p>default <code>TRUE</code>, whether to return the output to the current
session</p></dd>


<dt id="arg-savepath">savepath<a class="anchor" aria-label="anchor" href="#arg-savepath"></a></dt>
<dd><p>default <code>NULL</code>, a path to save the output to. Note that this
names the output rds file directly '<code>type</code>_aggregated.rds', so the path
should include only the directory structure.  If <code>NULL</code>, does not save. If
<code>savepath = NULL</code> and <code>returnList = FALSE</code>, the function errors to avoid
wasting resources.</p></dd>


<dt id="arg-extrameta">extrameta<a class="anchor" aria-label="anchor" href="#arg-extrameta"></a></dt>
<dd><p>list, extra information to include in saved metadata
documentation for the run. Default NULL.</p></dd>


<dt id="arg-rparallel">rparallel<a class="anchor" aria-label="anchor" href="#arg-rparallel"></a></dt>
<dd><p>logical, default FALSE. If TRUE, parallelises over the
scenarios in hydro_dir using <code>furrr</code>. To use, install <code>furrr</code> and set a
<code><a href="https://future.futureverse.org/reference/plan.html" class="external-link">future::plan()</a></code> (likely <code>multisession</code> or <code>multicore</code>)</p></dd>


<dt id="arg-par-recursive">par_recursive<a class="anchor" aria-label="anchor" href="#arg-par-recursive"></a></dt>
<dd><p>logical, default TRUE. If parallel, do we use the
innermost level of directory containing EWR outputs (TRUE) or the next
level in from datpath (FALSE)</p></dd>


<dt id="arg-savepar">savepar<a class="anchor" aria-label="anchor" href="#arg-savepar"></a></dt>
<dd><p>'combine' (default) or 'each'. If parallel over scenarios,
should this combine the output (default) or save each scenario's
aggregation separately ('each')</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>passed to <code><a href="read_and_geo.html">read_and_geo()</a></code>, primarily <code>gaugefilter</code>,
<code>scenariofilter</code>.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>either a tibble or sf of aggregated values at the final level (if
<code>saveintermediate = FALSE</code>) or a list of tibbles or sfs with aggregated
values at each step (<code>saveintermediate = TRUE</code>)</p>
    </div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Galen Holt, Georgia Dwyer.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.2.</p>
</div>

    </footer></div>





  </body></html>

