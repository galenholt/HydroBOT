% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_and_agg.R
\name{read_and_agg}
\alias{read_and_agg}
\title{Read in data and aggregate along theme and spatial dimensiont}
\usage{
read_and_agg(
  datpath,
  type,
  geopath,
  causalpath,
  groupers = "scenario",
  aggCols,
  aggsequence,
  funsequence,
  saveintermediate = FALSE,
  namehistory = TRUE,
  keepAllPolys = FALSE,
  failmissing = TRUE,
  returnList = TRUE,
  savepath = NULL,
  extrameta = NULL,
  ...
)
}
\arguments{
\item{datpath}{path to indicator data. Currently needs to be EWR (same as
\code{ewrpath} argument in \code{\link[=prep_ewr_agg]{prep_ewr_agg()}}), but left more general here for
future}

\item{type}{character of which type of EWR output (currently \code{'summary'},
\code{'annual'}, or \code{'both'}). New values, e.g. \verb{'all}' probably work but
untested.}

\item{geopath}{path to the file with gauge locations in lat/long (assumes BOM
currently), or an \code{sf} with gauge locations}

\item{causalpath}{path to the causal relationships .rds file. Should
typically be created in \verb{Causal networks}}

\item{groupers}{as in \code{\link[=general_aggregate]{general_aggregate()}}, with the note that these should
be all grouping columns \emph{except} theme and spatial groupings. These are
both automatically added to \code{groupers} according to \code{aggsequence} before
passing to \code{\link[=general_aggregate]{general_aggregate()}}.}

\item{aggCols}{an expression for the columns to aggregate (the data columns).
See \code{selectcreator} for formats}

\item{aggsequence}{a named list of aggregation steps in the order to apply
them. Entries for theme aggregation should be character vectors- e.g. \code{name = c('from_theme', 'to_theme')}. Entries for spatial aggregation should be
the sf polygon to aggregate to, e.g. \code{name = sfpolygons} or a length-1
character, e.g. \code{name = "sfpolygons"}. The latter requires the object to be
available with \verb{get("sfpolygons:)}, but allows passing characters rather
than objects. Not requiring names and is high on the list of improvements.
If we want to be able to re-run from auto-saved metadata params, we need
the names of the spatial levels to match the object, e.g. basin: basin.}

\item{funsequence}{a list of aggregation functions to apply in the order to
apply them. Each list entry can be one value, e.g. a character or bare
name, or can be multiple if mulitiple aggregations should be done at that
step, e.g. \code{c('ArithmeticMean', 'LimitingFactor')}. The entries can also be
lists themselves, useful for passing functions with arguments, e.g \code{list(wm = ~weighted.mean(., w = area, na.rm = TRUE))}. \emph{Important:} as of {dplyr}
1.1, if these are anonymous functions that refer to data variables (like
the \code{w = area} argument in the \code{\link[=weighted.mean]{weighted.mean()}} example), that list needs
to be wrapped in \code{\link[rlang:defusing-advanced]{rlang::quo()}}, e.g. \verb{rlang::quo(list(wm = ~weighted.mean(., w = area, na.rm = TRUE))}. And we can no longer mix
character and other forms in the same sub-list (single aggregation step).}

\item{saveintermediate}{logical, default \code{FALSE}. * \code{FALSE} (the default):
Save only the final result as a tibble or sf * \code{TRUE}: Save every step of
the aggregation as a tibble or sf in a list}

\item{namehistory}{logical, default \code{TRUE}. * \code{TRUE} (the default): The name
of the aggregated column(s) retain the full aggregation history of the form
\code{agglevelN_aggfunctionN_...agglevel1_aggfunction1_originalcolumn}. This is
ugly, but saves memory and says exactly what the values in each column are.
\itemize{
\item \code{FALSE}: The aggregation history is moved out of the column names and
into new columns that define it using \code{\link[=agg_names_to_cols]{agg_names_to_cols()}}. The column
name(s) become(s) the original column name(s) specified by \code{aggCols}. This
is far cleaner and easier for analysis (e.g. filtering on aggregation
functions at a particular step), but increases the size of the dataset and
the meaning of the values in the aggregation column have to be interpreted
with the values in the new columns defining history.
}}

\item{keepAllPolys}{logical, default \code{FALSE}. Should polygons in \code{to_geo}
that have no values in \code{dat} be retained? The default \code{FALSE} keeps NA
polygons from cluttering things up, but \code{TRUE} can be useful to not lose
them, especially for later plotting. However, it is typically best from a
data and cleanliness perspective to use \code{FALSE} here and use the bare set
of polys as an \code{underlay} in \code{\link[=plot_outcomes]{plot_outcomes()}}.}

\item{failmissing}{logical, default \code{TRUE}: fail if the requested grouping or
aggregation columns not exist. If \code{FALSE}, proceed with those that do exist
and silently drop those that don't. Similar to \code{tidyselect::all_of()} vs
\code{tidyselect::any_of()} in \code{tidyselect}}

\item{returnList}{default \code{TRUE}, whether to return the output to the current
session}

\item{savepath}{default \code{NULL}, a path to save the output to. Note that this
names the output rds file directly '\code{type}_aggregated.rds', so the path
should include only the directory structure.  If \code{NULL}, does not save. If
\code{savepath = NULL} and \code{returnList = FALSE}, the function errors to avoid
wasting resources.}

\item{...}{}
}
\value{
either a tibble or sf of aggregated values at the final level (if
\code{saveintermediate = FALSE}) or a list of tibbles or sfs with aggregated
values at each step (\code{saveintermediate = TRUE})
}
\description{
Allows passing only paths to data rather than objects. Wrapper over
\code{\link[=prep_ewr_agg]{prep_ewr_agg()}} (though can be made more general once we have other
modules), \code{\link[=make_edges]{make_edges()}} and \code{\link[=multi_aggregate]{multi_aggregate()}}. Particularly useful if we
want to pass parameters as strings from a config before anything is read in,
and parallelisation.
}
