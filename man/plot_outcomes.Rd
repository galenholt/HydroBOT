% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_outcomes.R
\name{plot_outcomes}
\alias{plot_outcomes}
\title{Standardized plot functions for toolkit.}
\usage{
plot_outcomes(
  outdf,
  outcome_col,
  outcome_lab = outcome_col,
  y_col = outcome_col,
  y_lab = y_col,
  x_col = "scenario",
  x_lab = x_col,
  colorset = "scenario",
  pal_list = "scico::berlin",
  pal_direction = rep(1, length(pal_list)),
  colorgroups = NULL,
  color_lab = ifelse(is.null(colorgroups), colorset, colorgroups),
  plot_type = "2d",
  facet_row = NULL,
  facet_col = NULL,
  facet_wrapper = NULL,
  point_group = NULL,
  sceneorder = NULL,
  scales = "fixed",
  transoutcome = "identity",
  transy = "identity",
  transx = "identity",
  zero_adjust = 0,
  position = "stack",
  base_list = NULL,
  smooth_arglist = NULL,
  underlay_list = NULL,
  overlay_list = NULL,
  contour_arglist = NULL,
  setLimits = NULL
)
}
\arguments{
\item{outdf}{dataframe of outcomes}

\item{outcome_col}{character, name of outcome column. This is the data of
interest being plotted. All data operations in \code{\link[=plot_data_prep]{plot_data_prep()}} happen to
this column, and \code{\link[=plot_style_prep]{plot_style_prep()}} bases styling on it. For 2d plots, it
is the y-axis, and for maps, heatmaps, and network plots, it is color/fill.
It is entirely possible to also use it as color/fill for 2d plots in
addition to the y-axis.}

\item{outcome_lab}{character, default \code{outcome_col}, allows changing label of
the outcome_col (y-axis or color/fill)}

\item{y_col}{character, default \code{outcome_col}. Allows separately specifying
y-axis from outcome (e.g. maps, heatmaps, networks)}

\item{y_lab}{character, default y_col, allows changing y-label}

\item{x_col}{character, name of column for the x-axis. Default \code{'scenario'}}

\item{x_lab}{character, default \code{x_col}, allows changing x-label}

\item{colorset}{character, column name to use for color or fill}

\item{pal_list}{list of palettes for defining colors for \code{colorset}. Should
be length of \code{colorgroups}}

\item{pal_direction}{vector of length pal_list, either 1 (default) or -1 (reversed) direction of the palettes}

\item{colorgroups}{character, column name for grouping \code{colorset} to allow
multiple palettes. Default NULL just uses colorset to define color}

\item{color_lab}{character, default either \code{colorgroups} or \code{colorset} (if
\code{is.null(colorgroups)}). Allows changing the color legend label}

\item{plot_type}{one of '2d' (default), 'heatmap', 'contour', 'map', or
'network'. Typically, '2d' can be inferred. Both 'heatmap' and 'contour'
call \code{plot_heatmap}, but do so differently. 'network' is being held for
future use (use \code{make_causal_plot()} in the interim)}

\item{facet_row}{NULL (default) or character for facet row. Can be \code{'.'} to
have one row and column-facets}

\item{facet_col}{NULL (default) or character for facet column. Can be \code{'.'}
to have one column and row-facets}

\item{facet_wrapper}{NULL (default) or character for column to use for
\code{facet_wrap}}

\item{point_group}{character, column to add additional point groupings to,
e.g. if plotting color by an environmental group, but need separate
lines/points for each environmental objective.}

\item{sceneorder}{Default NULL, otherwise, character or factor giving the
order to present scenario levels}

\item{scales}{facet scales, as in \code{\link[ggplot2:facet_wrap]{ggplot2::facet_wrap()}}. Default \code{scales = 'fixed'} holds them the same, most common change will be to \code{scales = 'free_y'} if e.g. gauges have very different flows.}

\item{transoutcome}{transformation for outcome as in
\code{\link[ggplot2:scale_continuous]{ggplot2::scale_y_continuous()}} or \code{\link[ggplot2:scale_colour_continuous]{ggplot2::scale_fill_continuous()}}.
Default \code{transoutcome = 'identity'} just uses the data. Most common change
likely \verb{transoutcome = 'log10}}

\item{transy}{transformation of y-axis, \emph{if the outcome is not y}. Default
\code{'identity'}. Ignored if outcome_col is on the y-axis}

\item{transx}{transformation for x axis as in
\code{\link[ggplot2:scale_continuous]{ggplot2::scale_x_continuous()}}. Default \code{transx = 'identity'} just uses
the data. Most common change likely \verb{transx = 'log10}.}

\item{zero_adjust}{adjustment of zeros in \code{\link[=plot_data_prep]{plot_data_prep()}}, useful
especially for axis \code{trans} arguments. See \code{?plot_data_prep}; this is not
the same as for baselining, which should go in \code{base_list}}

\item{position}{character or \code{position} function, \code{position} arguments from
\code{\link[ggplot2:geom_bar]{ggplot2::geom_col()}} and \code{\link[ggplot2:geom_point]{ggplot2::geom_point()}} (depending on plot type),
to change from stacked to dodged bars or jitter points. Can be character,
e.g. 'jitter' or a function, e.g. \code{ggplot2::position_jitter(width = 0.1, height = 0)}}

\item{base_list}{NULL (default) or named list of arguments to
\code{\link[=baseline_compare]{baseline_compare()}};
\itemize{
\item base_lev
\item comp_fun
\item group_cols
\code{\link[=plot_data_prep]{plot_data_prep()}} handles \code{zero_adjust}, and other arguments are inferred or
not supported
If \code{comp_fun} is 'difference' or 'relative', midpoint auto-set at 0 or 1
respectively unless otherwise specified with \code{setLimits}
}}

\item{smooth_arglist}{NULL (default) or limited list of arguments to
\code{\link[ggplot2:geom_smooth]{ggplot2::geom_smooth()}}. If NULL and x is quantitative, defaults to
straight lines. Arguments
\itemize{
\item method
\item method.args
\item se
\item linewidth
\item alpha
If others are desired, we can develop something more general.
}}

\item{underlay_list}{default NULL, otherwise named list (or list of named
lists for multiple underlay levels) of arguments to plot a map underlying
the main map data. Only required value is either \code{'underlay'} or
\code{'underover'} (interchangeable), defining the data to be plotted. Other
arguments as for the main plot. Typical examples
\itemize{
\item \code{underlay_list = 'basin'} simply plot the basin outline
\item \code{underlay_list = list(underlay = 'basin', pal_list = 'azure')} same, but filled
\item \code{underlay_list = list(underlay = outputs_on_sdl_scale, outcome_col = ewr_achieved, pal_list = 'scico::oslo')} plot the ewr outcomes in the sdls
A named palette (e.g. variation in color/fill) only works if the main data
is not the same type- we can't use different palettes for underlay fill and
main data fill, for example, but can if the underlay is fill (polygons) and
the main data is points.
}}

\item{overlay_list}{as \code{underlay_list}, but first item might be named
\verb{"overlay} or \code{"underover"}}

\item{contour_arglist}{default \code{NULL}
\itemize{
\item NULL builds a heatmap with \code{\link[ggplot2:geom_tile]{ggplot2::geom_tile()}},
\item \code{list(interpolate = TRUE)} builds an interpolated heatmap with \code{\link[ggplot2:geom_tile]{ggplot2::geom_raster()}} with \code{interpolate = TRUE}
\item \code{list()} builds a \code{\link[ggplot2:geom_contour]{ggplot2::geom_contour()}} with all defaults
\item a named list with names other than 'interpolate' passes those as arguments to \code{\link[ggplot2:geom_contour]{ggplot2::geom_contour()}}
}}

\item{setLimits}{sets user-supplied color/fill limits or midpoints for maps,
heatmaps, and networks, or y limits for other plots. Also sets \code{underlay}
and \code{overlay} limits for consistency.
\itemize{
\item NULL (default) use internally-calculated limits
\item length-1 numeric, sets midpoint, limits stay auto-calculated. V. useful for divergent
\item length-2 numeric, sets lower and upper limits
\item length-3 numeric, sets limits and midpoint \code{c(lower, mid, upper)}, with caveat that one limit may be ignored (must be symmetrical about the midpoint)
\item if base_list is 'difference' or 'relative', midpoints are auto-set at 0 or 1 (respectively) unless otherwise specified here.
}}
}
\value{
a ggplot stacked bar plot with standard formatting and data cleaning
}
\description{
Provides a common interface to plotting of an \code{outcome_col}, which may be
plotted on y or fill/color or both. Handles consistent data preparation steps
for that outcome variable, along with error and data checking. This keeps
data arrangement in-function and controlled for consistency and accuracy, no
matter what plot type is desired. Currently supports lines, points, bars,
maps, and heatmaps. All plots are just standardizatons of
\code{\link[ggplot2:ggplot]{ggplot2::ggplot()}}, and return \code{ggplot} objects that can then be tweaked
with standard ggplot calls. \strong{Unlike ggplot, arguments that would typically
go in \code{\link[ggplot2:aes]{ggplot2::aes()}} should not be bare names, but characters}.
}
\details{
I do \emph{not} provide an argument to drop legend labels on purpose- it's
dangerous to auto-drop them. The user can always \code{+ theme(legend.position = 'none')} to the returned object. As much as possible, arguments for specific
plot types have been put in \verb{*_list} arguments, which should be NULL
(typically the default) or lists of the arguments that the user wants to
change.
}
