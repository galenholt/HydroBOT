% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spatial_aggregate.R
\name{spatial_aggregate}
\alias{spatial_aggregate}
\title{Aggregate along spatial dimension}
\usage{
spatial_aggregate(
  dat,
  to_geo,
  groupers,
  aggCols,
  funlist,
  ...,
  whichcrs = sf::st_crs(to_geo),
  keepAllPolys = FALSE,
  failmissing = TRUE,
  prefix = "spatial_",
  joinby = "spatial",
  auto_ewr_PU = FALSE
)
}
\arguments{
\item{dat}{sf of values to aggregate with any necessary non-spatial grouping
information (e.g. scenario, theme)}

\item{to_geo}{sf polygon or multipolygon that provides the desired spatial
level to group into. This uses the intersection \code{\link[sf:geos_binary_ops]{sf::st_intersection()}}, so
if \code{dat} and \code{to_geo} are both polygons, they do not have to be nested.}

\item{groupers}{as in \code{\link[=general_aggregate]{general_aggregate()}}, with the note that these should
be all grouping columns \emph{except} the polygons in \code{to_geo}, which are
automatically added to \code{groupers} before passing to \code{\link[=general_aggregate]{general_aggregate()}}.}

\item{aggCols}{an expression for the columns to aggregate (the data columns).
See \code{selectcreator} for formats}

\item{funlist}{a list of functions and their arguments used to aggregate the
data. See \code{functionlister} for creation in many cases. The situation with a
bare anonymous function, e.g. \code{~mean(., na.rm = T)} is not supported
because we need a name. Use a named list if using anonymous functions, e.g.
\code{list(mean = ~mean(., na.rm = T))}. \emph{If using functions with a
data-variable argument}, e.g. weighted.mean with a column of weights, we
now (as of \code{dplyr} 1.1) have some workarounds. One option is if specified
\emph{as a function argument}, the function can just go in as a bare name or
anonymous. If specified elsewhere, it can be wrapped in \code{\link[rlang:defusing-advanced]{rlang::quo()}},
e.g. \code{agglist <- rlang::quo(list(mean = mean, wm = ~weighted.mean(., weight_column_name, na.rm = T)))}. If it isn't, there is now an internal
workaround to add that on that seems to be stable but may cause unforeseen
issues. This workaround also allows building custom aggregation functions
(not-anonymous) with the data-variable argument either exposed or hardcoded
(see \code{\link[=SpatialWeightedMean]{SpatialWeightedMean()}}). The error checks for names do not work for
quosures, so make sure you name the list if using \code{\link[rlang:defusing-advanced]{rlang::quo()}}.}

\item{...}{arguments passed to the aggregation functions. This is \emph{very}
limited, and does not work with data arguments under most conditions.
Almost always better to specify explicitly when building \code{funlist}, but
works OK with simple functions, e.g. passing \code{na.rm = TRUE} to mean}

\item{whichcrs}{desired coordinate reference system, easiest is just the
numeric EPSG code, but could a full crs definition. See \code{\link[sf:st_crs]{sf::st_crs()}}}

\item{keepAllPolys}{logical, default \code{FALSE}. Should polygons in \code{to_geo}
that have no values in \code{dat} be retained? The default \code{FALSE} keeps NA
polygons from cluttering things up, but \code{TRUE} can be useful to not lose
them, especially for later plotting. However, it is typically best from a
data and cleanliness perspective to use \code{FALSE} here and use the bare set
of polys as an \code{underlay} in \code{\link[=plot_outcomes]{plot_outcomes()}}.}

\item{failmissing}{logical, default \code{TRUE}: fail if the requested grouping or
aggregation columns not exist. If \code{FALSE}, proceed with those that do exist
and silently drop those that don't. Similar to \code{tidyselect::all_of()} vs
\code{tidyselect::any_of()} in \code{tidyselect}}

\item{prefix}{character, differs from \code{\link[=general_aggregate]{general_aggregate()}} in that default
is \code{'spatial_'} instead of \code{'agg_'}.}

\item{joinby}{character, default 'spatial' performs the expected spatial join using geometry, 'nonspatial' performs a \code{\link[dplyr:mutate-joins]{dplyr::left_join()}} by common column names, typically as a result of calling \code{\link[=multi_aggregate]{multi_aggregate()}} with \code{pseudo_spatial = 'planning_units'}.}

\item{auto_ewr_PU}{logical, default FALSE. If TRUE, automatically infers
whether this is an EWR dataset is undergoing gauge to planning unit aggregation.
If so, joins data non-spatially (sets \code{joinby = 'nonspatial'}). The preferred solution is
to use \code{joinby} in \code{\link[=spatial_aggregate]{spatial_aggregate()}} or \code{pseudo_spatial} in \code{\link[=multi_aggregate]{multi_aggregate()}}.
If none of those solutions happen, though, it aborts to
prevent incorrectly spatial joining of gauges to planning units.}
}
\value{
an \code{sf} with columns for the grouping variables aggregated into the
polygons in \code{to_geo} and retaining desired theme-level information
}
\description{
Takes geographic data (points or polygons), and aggregates into polygons,
while retaining theme-level information. This function sets up the data with
specific prep for the way the spatial dimension works, and then wraps
\code{\link[=general_aggregate]{general_aggregate()}}. Many of the arguments here are just passed through to
general aggregate.
}
