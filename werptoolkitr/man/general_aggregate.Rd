% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/general_aggregate.R
\name{general_aggregate}
\alias{general_aggregate}
\title{Aggregate data along theme dimension}
\usage{
general_aggregate(
  data,
  groupers,
  aggCols,
  funlist,
  prefix = "agg_",
  failmissing = TRUE,
  ...
)
}
\arguments{
\item{data}{a dataframe or tibble with data to aggregate}

\item{groupers}{an expression for the columns to use as grouping variables
for the aggregation (see \code{selectcreator} for formats)}

\item{aggCols}{an expression for the columns to aggregate (the data columns).
See \code{selectcreator} for formats}

\item{funlist}{a list of functions and their arguments used to aggregate the
data. See \code{functionlister} for creation in many cases. The situation with a
bare anonymous function, e.g. \code{~mean(., na.rm = T)} is not supported
because we need a name. Use a named list if using anonymous functions, e.g.
\code{list(mean = ~mean(., na.rm = T))}. \emph{If using functions with a
data-variable argument}, e.g. weighted.mean with a column of weights, we
now (as of {dplyr} 1.1) have some major restrictions. If specified \emph{as a
function argument}, the function can just go in as a bare name or
anonymous. If specified elsewhere, it \emph{has} to be wrapped in
\code{\link[rlang:defusing-advanced]{rlang::quo()}}, e.g. \code{agglist <- rlang::quo(list(mean = mean, wm = ~weighted.mean(., weight_column_name, na.rm = T)))}. And if building custom
aggregation functions (not-anonymous), the argument has to be exposed, it
can't be hardcoded into the function body. The error checks for names do
not work for quosures, so make sure you name the list.}

\item{prefix}{character prefix for the column name. Default \code{"agg_"}, but
often better to use the aggregation step. Typically set by particular
calling function to give it the type of aggregation}

\item{failmissing}{logical, default \code{TRUE}: fail if the requested grouping or
aggregation columns not exist. If \code{FALSE}, proceed with those that do exist
and silently drop those that don't. Similar to \code{tidyselect::all_of()} vs
\code{tidyselect::any_of()} in \code{tidyselect}}

\item{...}{arguments passed to the aggregation functions. This is \emph{very}
limited, and does not work with data arguments under most conditions.
Almost always better to specify explicitly when building \code{funlist}, but
works OK with simple functions, e.g. passing \code{na.rm = TRUE} to mean}
}
\value{
a tibble with columns for the grouping variables and a column of
within-group aggregated values for each \code{aggCol} and function in \code{funlist},
named according to the function applied and original name.
}
\description{
This is the core aggregation function for all the aggregation types. it's
really a fairly lightweight wrapper over a small dplyr::group_by and
summarise to handle passing in grouping columns, aggregation columns, and
functions as arguments and handle naming. It assumes no spatial information
to deal with. Preparing the data to have the proper grouping columns is the
job of the outer calling functions (or the user)
}
